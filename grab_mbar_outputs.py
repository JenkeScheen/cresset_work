#!/bin/python

import numpy as np
import csv
import glob

def retrieveMBARerror(path_to_errorfile):
	"""Read a MBAR error file and determine what went wrong"""
	error = None
	mbar_output = []
	with open(path_to_errorfile, "r") as readfile:
		reader = csv.reader(readfile)
		for line in reader:
			mbar_output += line

	if " column_sums[firstbad]" in mbar_output:
		error = "pyMBAR_overlap"
	elif 'IndexError: too many indices for array' in mbar_output:
		error = "PartCoordNaN"

	return error



def retrieveMBAROutput(path_to_datafile, verbose=False):
	"""
	Read SOMD-generated MBAR output file and return outputs
	--args
	path_to_datafile (str): path to SOMD-generated MBAR output file
	--returns
	overlap_matrix (array): phase-space overlap matrix generated by PyMBAR
	MBAR_freenrg (float): Free energy estimation generated by PyMBAR
	MBAR_error (float): Error estimation generated by PyMBAR
	"""
	overlap_matrix = None
	MBAR_freenrg = None
	MBAR_error = None
	OS = None

	if verbose:
		print("#####\n"+path_to_datafile)
	try:
		f = open(path_to_datafile, "r")
	except FileNotFoundError:
		print("Unable to find "+path_to_datafile)
		return (None, None, None)

	for line in f:

		## OVERLAP MATRIX
		# read the line after the #Overlap keyword for overlap matrix: 
		if "#Overlap matrix" in line:

			overlap_matrix = []
			# grab and process next line until end of matrix:
			row = next(f)
			while not row.startswith("#DG"):
				# format and append the matrix row:
				row = [ float(value) for value in row.split(" ") ]
				overlap_matrix.append(row)
				row = next(f)
			# convert to numpy array for returning:
			overlap_matrix = np.array(overlap_matrix)
			if verbose:
				print(np.array_str(overlap_matrix, precision=3, suppress_small=True))

			# compute overlap score if possible:
			off_diag_overlaps= []

			num_overlaps = len(overlap_matrix) -1
			for lambda_idx, matrix_row in zip(range(num_overlaps), overlap_matrix):
				off_diag_overlap = matrix_row[lambda_idx + 1]
				off_diag_overlaps.append(off_diag_overlap)

			mean_overlap = np.mean(off_diag_overlaps)
			# we're interested in consistency of the off-diagonal vector; but also in dips in overlap;
			# as such, count number of overlap values that fall on or below the recommended 0.03:
			low_overlaps = [val for val in off_diag_overlaps if val < 0.03]
			num_low_overlaps = len(low_overlaps)


			OS = mean_overlap/(num_low_overlaps+1)

		## FREENRG & ERROR
		# read the line after the #MBAR keyword for energy prediction: 
		if line.startswith("#MBAR"):
			# grab and process next line:
			prediction_line = next(f)
			MBAR_freenrg = prediction_line.split(", ")[0].split("  ")[0].rstrip()
			MBAR_error = prediction_line.split(", ")[1].split("  ")[0].rstrip()
			if verbose:
				print("Freenrg:", MBAR_freenrg)
				print("MBAR error:", MBAR_error)
				print("#####\n")
		if MBAR_freenrg == None:
			error = retrieveMBARerror(path_to_datafile.replace(".dat", ".err"))


	return overlap_matrix, OS, MBAR_freenrg, MBAR_error, error

# grab vac outputs:
with open("mbar_outputs_17w_ctl.csv", "w") as writefile:
	writer = csv.writer(writefile)

	perts = glob.glob("CHEMBL*")

	# grab all MBAR outputs:

	# free:
	for pert in perts:
		print(pert)
		pert_name = pert
		#mbar_path_v = pert+"/vacuum/MBAR.dat"
		mbar_path_f = pert+"/bound/MBAR.dat"

		#olp_mtx_v, olp_score_v, freenrg_v, mbar_unc_v, error_v = retrieveMBAROutput(mbar_path_v)
		olp_mtx_f, olp_score_f, freenrg_f, mbar_unc_f, error_f = retrieveMBAROutput(mbar_path_f)

		# write data to file:
		writer.writerow([pert_name, freenrg_f, mbar_unc_f, error_f, olp_mtx_f])
		# writer.writerow([pert_name, freenrg_v, mbar_unc_v, error_v, olp_mtx_v, 
		# 		freenrg_f, mbar_unc_f, error_f, olp_mtx_f])









